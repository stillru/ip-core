;;; ip-core.el --- Core module for IP management in Org-mode -*- lexical-binding: t; -*-

;;; Commentary:
;; Core utilities for IP Manager, including client and file handling.
;; This module provides the foundation for the IP management system.

;;; Code:
(require 'org-element)
(require 'cl-lib)
(require 'subr-x)

(defgroup ip-core nil
  "Personal business management via Org-mode."
  :prefix "ip-"
  :group 'applications)

(defcustom ip-org-directory "~/org/ip/"
  "Directory where IP-related Org files (e.g., company, clients, tasks) are stored."
  :type 'directory
  :group 'ip-core)

(defcustom ip-company-file "company.org"
  "Filename for personal company info."
  :type 'string
  :group 'ip-core)

(defcustom ip-clients-file "clients.org"
  "Filename for client definitions."
  :type 'string
  :group 'ip-core)

(defcustom ip-tasks-file "tasks.org"
  "Filename for task tracking."
  :type 'string
  :group 'ip-core)

;; Cache variables
(defvar ip--company-cache nil
  "Cache for company data.")

(defvar ip--company-cache-mtime nil
  "Modification time when company cache was last updated.")

(defvar ip--clients-cache nil
  "Cache for clients data.")

(defvar ip--clients-cache-mtime nil
  "Modification time when clients cache was last updated.")

;; Utility functions
(defun ip--get-full-path (filename)
  "Get full path for FILENAME in `ip-org-directory'."
  (expand-file-name filename ip-org-directory))

(defun ip--file-newer-than-cache-p (file cache-mtime)
  "Check if FILE is newer than CACHE-MTIME."
  (let ((file-mtime (when (file-exists-p file)
                      (nth 5 (file-attributes file)))))
    (or (null cache-mtime)
        (null file-mtime)
        (time-less-p cache-mtime file-mtime))))

(defun ip--ensure-directory ()
  "Ensure IP org directory exists."
  (unless (file-directory-p ip-org-directory)
    (make-directory ip-org-directory t)))

(defun ip--load-org-file (filename)
  "Return parsed Org AST from FILENAME in `ip-org-directory'."
  (let ((path (if (file-name-absolute-p filename)
                  filename
                (ip--get-full-path filename))))
    (unless (file-exists-p path)
      (error "File %s does not exist" path))
    (with-temp-buffer
      (insert-file-contents path)
      (org-element-parse-buffer))))

(defun ip--get-headlines (ast &optional level)
  "Extract headlines from AST at specified LEVEL (default 1)."
  (let ((target-level (or level 1)))
    (org-element-map ast 'headline
      (lambda (hl)
        (when (= (org-element-property :level hl) target-level)
          hl)))))

(defun ip--parse-properties (hl)
  "Extract :PROPERTIES: from a headline as plist."
  (let ((drawer (org-element-map hl 'property-drawer #'identity)))
    (if drawer
        (cl-loop for node in (org-element-contents (car drawer))
                 when (eq (org-element-type node) 'node-property)
                 append (list (intern (concat ":" (upcase (org-element-property :key node))))
                              (org-element-property :value node)))
      '())))

(defun ip--normalize-tag (name)
  "Normalize NAME for matching with tags (lowercase, no spaces or special chars)."
  (when name
    (downcase
     (replace-regexp-in-string "[^a-zA-Z0-9]" "" name))))

(defun ip--parse-services (client-hl)
  "Parse services from CLIENT-HL sub-headlines."
  (org-element-map client-hl 'headline
    (lambda (sub-hl)
      (when (= (org-element-property :level sub-hl) 2)
        (let* ((service-name (org-element-property :raw-value sub-hl))
               (props (ip--parse-properties sub-hl))
               (tag (or (plist-get props :TAG)
                        (ip--normalize-tag service-name))))
          (append
           (list :description service-name
                 :tag tag)
           props))))))

(defun ip--load-clients-data ()
  "Load client data from clients file with caching."
  (let ((clients-path (ip--get-full-path ip-clients-file)))
    (when (ip--file-newer-than-cache-p clients-path ip--clients-cache-mtime)
      (condition-case err
          (progn
            (setq ip--clients-cache-mtime (when (file-exists-p clients-path)
                                            (nth 5 (file-attributes clients-path))))
            (if (file-exists-p clients-path)
                (let ((ast (ip--load-org-file clients-path)))
                  (setq ip--clients-cache
                        (cl-loop for hl in (ip--get-headlines ast)
                                 collect (let* ((client-name (org-element-property :raw-value hl))
                                                (props (ip--parse-properties hl))
                                                (client-id (or (plist-get props :ID)
                                                               (ip--normalize-tag client-name)))
                                                (services (ip--parse-services hl)))
                                           (append (list :NAME client-name :ID client-id)
                                                   props
                                                   (when services (list :services services)))))))
              (progn
                (message "Clients file not found: %s" clients-path)
                (setq ip--clients-cache nil))))
        (error
         (message "Error loading clients data: %s" (error-message-string err))
         (setq ip--clients-cache nil))))
    ip--clients-cache))

(defun ip--load-company-data ()
  "Load company data from company file with caching."
  (let ((company-path (ip--get-full-path ip-company-file)))
    (when (ip--file-newer-than-cache-p company-path ip--company-cache-mtime)
      (condition-case err
          (progn
            (setq ip--company-cache-mtime (when (file-exists-p company-path)
                                            (nth 5 (file-attributes company-path))))
            (if (file-exists-p company-path)
                (let* ((ast (ip--load-org-file company-path))
                       (hl (car (ip--get-headlines ast))))
                  (if hl
                      (let ((props (ip--parse-properties hl)))
                        (setq ip--company-cache
                              (append (list :NAME (org-element-property :raw-value hl))
                                      props)))
                    (progn
                      (message "No headlines found in %s" company-path)
                      (setq ip--company-cache nil))))
              (progn
                (message "Company file not found: %s" company-path)
                (setq ip--company-cache nil))))
        (error
         (message "Error loading company data: %s" (error-message-string err))
         (setq ip--company-cache nil))))
    ip--company-cache))

(defun ip-get-clients (&optional refresh)
  "Return list of clients as plists from `clients.org'.
If REFRESH is non-nil, force reload from file."
  (ip--ensure-directory)
  (when refresh
    (setq ip--clients-cache nil
          ip--clients-cache-mtime nil))
  (ip--load-clients-data))

(defun ip-get-company-info (&optional refresh)
  "Return company info from `company.org' as plist (first headline).
If REFRESH is non-nil, force reload from file."
  (ip--ensure-directory)
  (when refresh
    (setq ip--company-cache nil
          ip--company-cache-mtime nil))
  (ip--load-company-data))

(defun ip-get-client-by-id (client-id)
  "Get client data by CLIENT-ID."
  (cl-find client-id (ip-get-clients)
           :key (lambda (c) (plist-get c :ID))
           :test 'equal))

(defun ip-get-client-service (client-id service-tag)
  "Get service data for CLIENT-ID and SERVICE-TAG."
  (let ((client (ip-get-client-by-id client-id)))
    (when client
      (cl-find service-tag (plist-get client :services)
               :key (lambda (s) (plist-get s :tag))
               :test 'equal))))

(defun ip-list-client-ids ()
  "Return list of all client IDs."
  (mapcar (lambda (c) (plist-get c :ID)) (ip-get-clients)))

(defun ip-list-service-tags ()
  "Return list of all service tags across all clients."
  (cl-loop for client in (ip-get-clients)
           when (plist-get client :services)
           append (mapcar (lambda (s) (plist-get s :tag))
                          (plist-get client :services))))

(defun ip-validate-setup ()
  "Validate that the IP system is properly set up."
  (let ((issues '()))
    (unless (file-directory-p ip-org-directory)
      (push (format "Directory does not exist: %s" ip-org-directory) issues))
    
    (let ((company-file (ip--get-full-path ip-company-file)))
      (unless (file-exists-p company-file)
        (push (format "Company file missing: %s" company-file) issues)))
    
    (let ((clients-file (ip--get-full-path ip-clients-file)))
      (unless (file-exists-p clients-file)
        (push (format "Clients file missing: %s" clients-file) issues)))
    
    (let ((tasks-file (ip--get-full-path ip-tasks-file)))
      (unless (file-exists-p tasks-file)
        (push (format "Tasks file missing: %s" tasks-file) issues)))
    
    (when issues
      (error "IP system setup issues:\n%s" (mapconcat 'identity issues "\n")))
    
    ;; Try to load data
    (condition-case err
        (ip-get-company-info)
      (error (push (format "Error loading company data: %s" 
                           (error-message-string err)) issues)))
    
    (condition-case err
        (ip-get-clients)
      (error (push (format "Error loading clients data: %s" 
                           (error-message-string err)) issues)))
    
    (if issues
        (error "IP system validation failed:\n%s" (mapconcat 'identity issues "\n"))
      (message "IP system validation successful"))))

;;;###autoload
(defun ip-show-overview ()
  "Show summary of company and client list. Print all properties for debugging."
  (interactive)
  (condition-case err
      (let ((company (ip-get-company-info))
            (clients (ip-get-clients)))
        (with-current-buffer (get-buffer-create "*IP Overview*")
          (let ((inhibit-read-only t))
            (erase-buffer)
            (insert "=== IP Management System Overview ===\n\n")
            
            ;; Company section
            (insert "Company Information:\n")
            (insert (make-string 40 ?-) "\n")
            (if company
                (progn
                  (insert (format "Name: %s\n" (or (plist-get company :NAME) "N/A")))
                  (insert (format "Address: %s\n" (or (plist-get company :ADDRESS) "N/A")))
                  (insert (format "Email: %s\n" (or (plist-get company :EMAIL) "N/A")))
                  (insert (format "Phone: %s\n" (or (plist-get company :PHONE) "N/A")))
                  (insert (format "IBAN: %s\n" (or (plist-get company :IBAN) "N/A")))
                  (insert (format "Tax ID: %s\n" (or (plist-get company :TAX_ID) "N/A")))
                  (insert "\nAll Company Properties (Debug):\n")
                  (cl-loop for (key value) on company by #'cddr
                           do (insert (format "  %-20s: %s\n" key value))))
              (insert "No company data available\n"))
            
            (insert "\n\nClients:\n")
            (insert (make-string 40 ?-) "\n")
            (if clients
                (progn
                  (insert (format "Total clients: %d\n\n" (length clients)))
                  (dolist (c clients)
                    (insert (format "• %s (ID: %s)\n"
                                    (or (plist-get c :NAME) "Unknown")
                                    (or (plist-get c :ID) "N/A")))
                    (when (plist-get c :EMAIL)
                      (insert (format "  Email: %s\n" (plist-get c :EMAIL))))
                    (when (plist-get c :DEFAULT_RATE)
                      (insert (format "  Default Rate: %s %s/hr\n" 
                                      (plist-get c :DEFAULT_RATE)
                                      (or (plist-get c :CURRENCY) "EUR"))))
                    (when (plist-get c :services)
                      (insert "  Services:\n")
                      (dolist (s (plist-get c :services))
                        (insert (format "    - %s (tag: %s, rate: %s)\n"
                                        (plist-get s :description)
                                        (plist-get s :tag)
                                        (or (plist-get s :RATE) "default")))))
                    (insert "\n")))
              (insert "No clients available\n"))
            
            ;; System info
            (insert "\nSystem Information:\n")
            (insert (make-string 40 ?-) "\n")
            (insert (format "Org Directory: %s\n" ip-org-directory))
            (insert (format "Company File: %s\n" (ip--get-full-path ip-company-file)))
            (insert (format "Clients File: %s\n" (ip--get-full-path ip-clients-file)))
            (insert (format "Tasks File: %s\n" (ip--get-full-path ip-tasks-file)))
            
            (goto-char (point-min))
            (read-only-mode 1))
          (display-buffer (current-buffer))))
    (error (message "Error generating overview: %s" (error-message-string err)))))

;;;###autoload
(defun ip-setup-files ()
  "Create template files for IP system if they don't exist."
  (interactive)
  (ip--ensure-directory)
  
  ;; Create company.org template
  (let ((company-file (ip--get-full-path ip-company-file)))
    (unless (file-exists-p company-file)
      (with-temp-file company-file
        (insert "#+TITLE: Company Information\n\n")
        (insert "* My Company\n")
        (insert ":PROPERTIES:\n")
        (insert ":NAME: My Company Name\n")
        (insert ":ADDRESS: 123 Main St, City, Country\n")
        (insert ":EMAIL: contact@mycompany.com\n")
        (insert ":PHONE: +1-555-0123\n")
        (insert ":IBAN: DE89370400440532013000\n")
        (insert ":TAX_ID: 123456789\n")
        (insert ":END:\n\n")
        (insert "Company description and notes go here.\n"))
      (message "Created company template: %s" company-file)))
  
  ;; Create clients.org template
  (let ((clients-file (ip--get-full-path ip-clients-file)))
    (unless (file-exists-p clients-file)
      (with-temp-file clients-file
        (insert "#+TITLE: Clients\n\n")
        (insert "* Example Client\n")
        (insert ":PROPERTIES:\n")
        (insert ":ID: client1\n")
        (insert ":EMAIL: client@example.com\n")
        (insert ":ADDRESS: 456 Client St, Client City, Country\n")
        (insert ":CURRENCY: EUR\n")
        (insert ":DEFAULT_RATE: 50\n")
        (insert ":TAX_RATE: 20\n")
        (insert ":PAYMENT_DETAILS: Bank transfer to IBAN: DE89370400440532013000\n")
        (insert ":END:\n\n")
        (insert "** Development\n")
        (insert ":PROPERTIES:\n")
        (insert ":TAG: dev\n")
        (insert ":RATE: 60\n")
        (insert ":TAXABLE: t\n")
        (insert ":END:\n\n")
        (insert "** Consulting\n")
        (insert ":PROPERTIES:\n")
        (insert ":TAG: consulting\n")
        (insert ":RATE: 80\n")
        (insert ":TAXABLE: t\n")
        (insert ":END:\n\n"))
      (message "Created clients template: %s" clients-file)))
  
  ;; Create tasks.org template
  (let ((tasks-file (ip--get-full-path ip-tasks-file)))
    (unless (file-exists-p tasks-file)
      (with-temp-file tasks-file
        (insert "#+TITLE: Tasks\n\n")
        (insert "* Example Task :client1:dev:\n")
        (insert "CLOCK: [2025-01-01 Mon 09:00]--[2025-01-01 Mon 17:00] =>  8:00\n")
        (insert "\nTask description goes here.\n\n")
        (insert "* Another Task :client1:consulting:\n")
        (insert "CLOCK: [2025-01-02 Tue 10:00]--[2025-01-02 Tue 12:00] =>  2:00\n")
        (insert "\nConsulting work description.\n\n"))
      (message "Created tasks template: %s" tasks-file)))
  
  (message "IP system files created successfully!"))

;;;###autoload
(defun ip-refresh-cache ()
  "Refresh all caches."
  (interactive)
  (setq ip--company-cache nil
        ip--company-cache-mtime nil
        ip--clients-cache nil
        ip--clients-cache-mtime nil)
  (message "IP core cache refreshed"))

(provide 'ip-core)
;;; ip-core.el ends here;;; ip-debug.el --- Unified debug logging for IP system -*- lexical-binding: t; -*-

;;; Commentary:
;; Unified logging and debugging utilities for the IP task/invoice system.
;; This is an optional module that provides enhanced logging capabilities.
;; If not loaded, modules fall back to minimal logging via `message'.

;;; Code:

(require 'org-element)
(require 'ip-core)
(require 'cl-lib)

(defgroup ip-debug nil
  "Unified logging and debugging utilities for the IP task/invoice system."
  :group 'ip-core)

(defcustom ip-debug-enabled t
  "Whether to enable debug logging."
  :type 'boolean
  :group 'ip-debug)

(defcustom ip-debug-main-buffer "*IP Debug Log*"
  "Main buffer name used for unified logging messages."
  :type 'string
  :group 'ip-debug)

(defcustom ip-debug-module-buffers t
  "Whether to create separate buffers for each module."
  :type 'boolean
  :group 'ip-debug)

(defvar ip-debug--module-buffers '()
  "Alist of (MODULE . BUFFER-NAME) for module-specific buffers.")

(defvar ip-tasks-file nil
  "Path to the Org file containing IP tasks. Provided by `ip-core.el`.")

(declare-function ip--load-org-file "ip-core.el")
(declare-function ip--task-in-range-p "ip-core.el")
(declare-function ip--parse-task-detailed "ip-core.el")


(defun ip-debug--get-module-buffer (module)
  "Get or create buffer name for MODULE."
  (when ip-debug-module-buffers
    (let ((buffer-name (alist-get module ip-debug--module-buffers)))
      (unless buffer-name
        (setq buffer-name (format "*IP Debug %s*" (capitalize (symbol-name module))))
        (push (cons module buffer-name) ip-debug--module-buffers))
      buffer-name)))

(defun ip-debug-log (level module message &rest args)
  "Log MESSAGE with LEVEL from MODULE to debug buffers.
LEVEL can be \='info, \='success, \='warning, or \='error.
MODULE should be a symbol like \='core, \='forgejo, \='invoice."
  (when ip-debug-enabled
    (let* ((formatted-msg (apply #'format message args))
           (timestamp (format-time-string "[%H:%M:%S] "))
           (module-str (format "[%s] " (upcase (symbol-name module))))
           (icon (pcase level
                   ('info "ℹ️")
                   ('success "✅")
                   ('warning "⚠️")
                   ('error "❌")
                   (_ "🔍")))
           (full-message (format "%s%s %s%s\n" timestamp icon module-str formatted-msg)))
      
      ;; Log to main unified buffer
      (with-current-buffer (get-buffer-create ip-debug-main-buffer)
        (let ((inhibit-read-only t))
          (goto-char (point-max))
          (insert full-message)))
      
      ;; Log to module-specific buffer if enabled
      (when-let ((module-buffer (ip-debug--get-module-buffer module)))
        (with-current-buffer (get-buffer-create module-buffer)
          (let ((inhibit-read-only t))
            (goto-char (point-max))
            (insert (format "%s%s %s\n" timestamp icon formatted-msg))))))))

(defmacro ip-debug (module message &rest args)
  "Log MESSAGE from MODULE as \='info\=' level using \=`ip-debug-log\='."
  `(ip-debug-log 'info ,module ,message ,@args))

(defun ip-debug-show (&optional module)
  "Display the debug buffer.
If MODULE is specified, show that module\'s buffer, otherwise show main buffer."
  (interactive
   (list (when current-prefix-arg
           (intern (completing-read "Module: " 
                                    (mapcar (lambda (x) (symbol-name (car x))) 
                                            ip-debug--module-buffers))))))
  (let ((buffer-name (if module
                         (ip-debug--get-module-buffer module)
                       ip-debug-main-buffer)))
    (pop-to-buffer buffer-name)))

(defun ip-debug-clear (&optional module)
  "Clear the debug buffer.
If MODULE is specified, clear that module's buffer, otherwise clear main buffer."
  (interactive
   (list (when current-prefix-arg
           (intern (completing-read "Module: " 
                                    (mapcar (lambda (x) (symbol-name (car x))) 
                                            ip-debug--module-buffers))))))
  (let ((buffer-name (if module
                         (ip-debug--get-module-buffer module)
                       ip-debug-main-buffer)))
    (when (get-buffer buffer-name)
      (with-current-buffer buffer-name
        (let ((inhibit-read-only t))
          (erase-buffer))))))

(defun ip-debug-clear-all ()
  "Clear all debug buffers."
  (interactive)
  (ip-debug-clear)  ; Clear main buffer
  (dolist (entry ip-debug--module-buffers)
    (when (get-buffer (cdr entry))
      (with-current-buffer (cdr entry)
        (let ((inhibit-read-only t))
          (erase-buffer))))))

(defun ip-debug-list-buffers ()
  "Show list of all debug buffers."
  (interactive)
  (let ((buffers (cons ip-debug-main-buffer 
                       (mapcar #'cdr ip-debug--module-buffers))))
    (message "IP Debug buffers: %s" (string-join buffers ", "))))

;; Provide fallback functions for when ip-debug is not loaded
(defvar ip-debug-fallback-functions
  '((ip-debug-log . ip-debug--fallback-log)
    (ip-debug . ip-debug--fallback-debug))
  "Fallback functions when ip-debug is not available.")

(defun ip-debug--fallback-log (level module message &rest args)
  "Fallback logging function that uses `message'."
  (let ((formatted-msg (apply #'format message args))
        (level-str (pcase level
                     ('info "INFO")
                     ('success "SUCCESS")
                     ('warning "WARNING") 
                     ('error "ERROR")
                     (_ "DEBUG")))
        (module-str (upcase (symbol-name module))))
    (message "[%s/%s] %s" module-str level-str formatted-msg)))

(defmacro ip-debug--fallback-debug (module message &rest args)
  "Fallback debug macro that uses `message'."
  `(ip-debug--fallback-log 'info ,module ,message ,@args))

;;; Invoice-specific debug functions

(defun ip-debug-client-properties ()
  "Debug function to examine all CLIENT properties in tasks."
  (interactive)
  (let ((ast (ip--load-org-file ip-tasks-file))
        (clients-found (make-hash-table :test 'equal))
        (total-tasks 0)
        (valid-client-ids (ip-list-client-ids)))  ; Get valid client IDs
    (ip-debug-log 'info 'debug "=== Debugging Client Properties ===")
    (org-element-map ast 'headline
      (lambda (hl)
        (cl-incf total-tasks)
        (let* ((props (org-element-property :properties hl))
               (client-raw (cdr (assoc-string "CLIENT" props t)))
               ;; Check tags if CLIENT property is not found
               (tags (org-element-property :tags hl))
               (client-from-tags (cl-find-if
                                  (lambda (tag)
                                    (member (ip--normalize-tag tag) valid-client-ids))
                                  tags))
               (client (or client-raw
                           (when client-from-tags
                             (ip--normalize-tag client-from-tags))
                           "unknown"))
               (title (org-element-property :raw-value hl)))
          (puthash client (1+ (gethash client clients-found 0)) clients-found)
          (ip-debug-log 'info 'debug "--- Task %d: %s ---" total-tasks title)
          (ip-debug-log 'info 'debug "  Raw CLIENT property: %S" client-raw)
          (ip-debug-log 'info 'debug "  Tags: %S" tags)
          (ip-debug-log 'info 'debug "  Processed client: %S" client)
          (ip-debug-log 'info 'debug "  All properties: %S" props)
          (ip-debug-log 'info 'debug "  Has clock entries: %s"
                        (if (org-element-map hl 'clock #'identity) "YES" "NO")))))
    (ip-debug-log 'info 'debug "=== All Clients Found (Summary) ===")
    (maphash (lambda (client count)
               (ip-debug-log 'info 'debug "  %s: %d tasks" client count))
             clients-found)
    (ip-debug-log 'info 'debug "Total tasks processed: %d" total-tasks)))

(defun ip-debug-task-detailed-parsing ()
  "Debug the detailed task parsing specifically."
  (interactive)
  (let* ((start "2025-07-01")
         (end "2025-07-30")
         (ast (ip--load-org-file ip-tasks-file))
         (all-tasks 0)
         (tasks-in-range 0)
         (maketv-tasks 0))
    (ip-debug-log 'info 'debug "=== Debugging Detailed Task Parsing ===")
    (org-element-map ast 'headline
      (lambda (hl)
        (cl-incf all-tasks)
        (when (ip--task-in-range-p hl start end)
          (cl-incf tasks-in-range)
          (let* ((parsed (ip--parse-task-detailed hl))
                 (client (plist-get parsed :client))
                 (title (plist-get parsed :title)))
            (ip-debug-log 'info 'debug "Task %d: %s" tasks-in-range title)
            (ip-debug-log 'info 'debug "  Client: %S" client)
            (when (string= client "maketv")
              (cl-incf maketv-tasks)
              (ip-debug-log 'success 'debug "  *** THIS IS A MAKETV TASK ***"))))))
    (ip-debug-log 'info 'debug "=== Summary ===")
    (ip-debug-log 'info 'debug "All tasks: %d" all-tasks)
    (ip-debug-log 'info 'debug "Tasks in range: %d" tasks-in-range)
    (ip-debug-log 'info 'debug "MakeTV tasks in range: %d" maketv-tasks)))

(defun ip-debug-string-comparison ()
  "Debug string comparison for client matching."
  (interactive)
  (let ((test-strings '("maketv" "MAKETV" "MakeTV" " maketv " "maketv\n")))
    (ip-debug-log 'info 'debug "=== String Comparison Debug ===")
    (dolist (test test-strings)
      (ip-debug-log 'info 'debug "Testing: %S" test)
      (ip-debug-log 'info 'debug "  string= with 'maketv': %s" (string= test "maketv"))
      (ip-debug-log 'info 'debug "  string-equal with 'maketv': %s" (string-equal test "maketv"))
      (ip-debug-log 'info 'debug "  after string-trim: %S" (string-trim test))
      (ip-debug-log 'info 'debug "  after downcase: %S" (downcase test)))))

;; Enhanced version of the parsing function with better debugging
(defun ip--parse-task-detailed-debug (task)
  "Extract detailed info from TASK headline with debugging."
  (condition-case err
      (let* ((props (org-element-property :properties task))
             (client-raw (cdr (assoc-string "CLIENT" props t)))
             (client (or client-raw "unknown"))
             (service (or (cdr (assoc-string "REPO" props t)) "general"))
             (title (org-element-property :raw-value task)))
        (ip-debug-log 'info 'debug "  Parsing task: %s" title)
        (ip-debug-log 'info 'debug "    Raw CLIENT: %S" client-raw)
        (ip-debug-log 'info 'debug "    Processed CLIENT: %S" client)
        (ip-debug-log 'info 'debug "    String= maketv: %s" (string= client "maketv"))
        (list :title title :client client :service service :element task))
    (error 
     (ip-debug-log 'error 'debug "Error parsing detailed task: %s" (error-message-string err))
     nil)))

;; Test function to run the detailed parsing with debug output
(defun ip-debug-test-detailed-parsing ()
  "Test detailed parsing with debug output."
  (interactive)
  (let* ((start "2025-07-01")
         (end "2025-07-30")
         (ast (ip--load-org-file ip-tasks-file))
         (count 0))
    (ip-debug-log 'info 'debug "=== Testing Detailed Parsing with Debug ===")
    (cl-loop for hl in (org-element-map ast 'headline #'identity)
             when (ip--task-in-range-p hl start end)
             do (progn
                  (cl-incf count)
                  (ip-debug-log 'info 'debug "=== Task %d ===" count)
                  (let ((parsed (ip--parse-task-detailed-debug hl)))
                    (when (and parsed (string= (plist-get parsed :client) "maketv"))
                      (ip-debug-log 'success 'debug "*** FOUND MAKETV TASK! ***")))))))

(provide 'ip-debug)
;;; ip-debug.el ends here;;; ip-forgejo.el --- Org importer from Forgejo issues -*- lexical-binding: t; -*-

;;; Commentary:
;; This module handles synchronization between Forgejo issues and Org-mode.
;; It fetches assigned issues, their time logs, and comments, formats them as Org entries,
;; and inserts or updates them in the current buffer.
;; Supports two-way sync for status, time, body, and deadlines.
;; Designed for multi-client reporting workflows.

;;; Code:

(eval-and-compile
  ;; Define fallback logging functions to satisfy compiler
  (unless (fboundp 'ip-debug-log)
    (defun ip-debug-log (level module message &rest args)
      "Fallback logging function that uses `message'.
LEVEL is the log level (\\='info, \\='success, \\='warning, \\='error).
MODULE is the module name (symbol).
MESSAGE is the format string, followed by ARGS."
      (let ((formatted-msg (apply #'format message args))
            (level-str (pcase level
                         ('info "INFO")
                         ('success "SUCCESS")
                         ('warning "WARNING")
                         ('error "ERROR")
                         (_ "DEBUG")))
            (module-str (upcase (symbol-name module))))
        (message "[%s/%s] %s" module-str level-str formatted-msg))))

  (unless (fboundp 'ip-debug)
    (defmacro ip-debug (module message &rest args)
      "Fallback debug macro that uses `ip-debug-log'.
MODULE is the module name (symbol).
MESSAGE is the format string, followed by ARGS."
      `(ip-debug-log 'info ,module ,message ,@args))))


(require 'request)
(require 'org)
(require 'org-element)
(require 'time-date)

;; Try to load ip-debug, provide fallbacks if not available
(condition-case nil
    (require 'ip-debug)
  (error
   ;; Define fallback functions if ip-debug is not available
   (defun ip-debug-log (level module message &rest args)
     "Fallback logging function that uses `message'."
     (let ((formatted-msg (apply #'format message args))
           (level-str (pcase level
                        ('info "INFO")
                        ('success "SUCCESS")
                        ('warning "WARNING") 
                        ('error "ERROR")
                        (_ "DEBUG")))
           (module-str (upcase (symbol-name module))))
       (message "[%s/%s] %s" module-str level-str formatted-msg)))
   
   (defmacro ip-debug (module message &rest args)
     "Fallback debug macro that uses `message'."
     `(ip-debug-log 'info ,module ,message ,@args))))

(defgroup ip-forgejo nil
  "Synchronization between local Org files and Forgejo issues."
  :group 'ip-core)

(defcustom ip-forgejo-instances
  '(("work"    . (("base-url" . "https://git.company.com/api/v1")
                  ("token"    . "tkn_work_123")))
    ("home"    . (("base-url" . "https://git.home.org/api/v1")
                  ("token"    . "tkn_home_456")))
    ("client"  . (("base-url" . "http://git.maketv.internal/api/v1")
                  ("token"    . "52ba51cd10ba0250444d872e10ac1dd730cee076"))))
  "List of Forgejo instances: ((NAME . ((\"base-url\" . URL) (\"token\" . TOKEN)))...)"
  :type '(alist :key-type string :value-type (alist :key-type string :value-type string))
  :group 'ip-forgejo)

(defcustom ip-forgejo-current-instance "client"
  "Default Forgejo instance to use."
  :type 'string
  :group 'ip-forgejo)

(defvar ip-forgejo--cache (make-hash-table :test 'equal)
  "Cache for API responses.")

(defun ip-forgejo--current-config ()
  "Return (base-url . token) for current instance."
  (let* ((instance (assoc ip-forgejo-current-instance ip-forgejo-instances)))
    (unless instance
      (ip-debug-log 'error 'forgejo "Unknown Forgejo instance: %s" ip-forgejo-current-instance)
      (user-error "Unknown Forgejo instance: %s" ip-forgejo-current-instance))
    (let ((config (cdr instance)))
      (cons (alist-get "base-url" config nil nil #'equal)
            (alist-get "token" config nil nil #'equal)))))

;;;###autoload
(defun ip-forgejo-switch-instance ()
  "Switch current Forgejo instance."
  (interactive)
  (let ((names (mapcar 'car ip-forgejo-instances)))
    (setq ip-forgejo-current-instance
          (completing-read "Switch to instance: " names nil t))
    (ip-debug-log 'info 'forgejo "Switched to instance: %s" ip-forgejo-current-instance)))

(defun ip-forgejo--clean-body (body)
  "Remove ^M and normalize line endings."
  (when body
    (replace-regexp-in-string "\r\n?" "\n" body)))

(defun ip-forgejo--ensure-list (value)
  "Convert VALUE to list if it's a vector or nil."
  (cond
   ((null value) '())
   ((vectorp value) (append value nil))
   ((listp value) value)
   (t (list value))))

;; Keep the specific Forgejo sync process buffer for detailed reports
(defun ip-forgejo--log (level message &rest args)
  "Log MESSAGE with LEVEL to sync process buffer AND unified debug system."
  (let ((formatted-msg (apply #'format message args))
        (timestamp (format-time-string "[%H:%M:%S] "))
        (icon (pcase level
                ('info "ℹ️")
                ('success "✓")
                ('warning "⚠️")
                ('error "❌")
                (_ "?"))))
    ;; Log to unified debug system
    (ip-debug-log level 'forgejo "%s" formatted-msg)
    ;; Also log to specific sync process buffer for detailed reports
    (with-current-buffer (get-buffer-create "*Forgejo Sync Report*")
      (let ((inhibit-read-only t))
        (goto-char (point-max))
        (insert (format "%s%s %s\n" timestamp icon formatted-msg))))))

(defun ip-forgejo--format-org-timestamp (iso8601-str)
  "Convert ISO 8601 string to Org-mode timestamp format."
  (when iso8601-str
    (let ((time (ignore-errors (date-to-time iso8601-str))))
      (when time
        (format-time-string "%Y-%m-%d %a" time)))))

(defun ip-forgejo--safe-get (alist key &optional default)
  "Safely get KEY from ALIST, returning DEFAULT if not found."
  (let ((value (alist-get key alist)))
    (if (and value (not (string-empty-p (format "%s" value))))
        value
      default)))

(defun ip-forgejo--api (url &optional headers)
  "Send a synchronous GET request to Forgejo API at URL."
  (let* ((config (ip-forgejo--current-config))
         (token (cdr config))
         (auth-header `("Authorization" . ,(concat "token " token)))
         (all-headers (cons auth-header (or headers '())))
         (cached (gethash url ip-forgejo--cache)))
    (when cached
      (ip-forgejo--log 'info "Cache hit: %s" url)
      (cl-return-from ip-forgejo--api cached))
    (ip-forgejo--log 'info "Request: GET %s" url)
    (condition-case err
        (let* ((result
                (request url
                         :type "GET"
                         :headers all-headers
                         :parser (lambda ()
                                   (condition-case parse-err
                                       (json-parse-string (buffer-string)
                                                          :object-type 'alist
                                                          :array-type 'list
                                                          :null-object nil
                                                          :false-object :false)
                                     (error
                                      (ip-forgejo--log 'error "JSON parse error: %s" (error-message-string parse-err))
                                      nil)))
                         :sync t
                         :timeout 30))
               (response-data (request-response-data result))
               (status (request-response-status-code result)))
          (if (and (>= status 200) (< status 300))
              (progn
                (ip-forgejo--log 'success "Response: %d bytes" (length (prin1-to-string response-data)))
                (puthash url response-data ip-forgejo--cache)
                response-data)
            (progn
              (ip-forgejo--log 'error "HTTP %d: %s" status (buffer-string))
              nil)))
      (error
       (ip-forgejo--log 'error "Request failed: %s" (error-message-string err))
       nil))))

(defun ip-forgejo--org-todo-state (state)
  "Convert Forgejo issue STATE to Org-mode TODO keyword."
  (pcase state
    ("open" "TODO")
    ("closed" "DONE")
    (_ "TODO")))

(defun ip-forgejo--format-logbook (entries)
  "Format a list of time log ENTRIES into Org-mode :LOGBOOK: CLOCK lines."
  (if (null entries)
      ""
    (let ((formatted-entries
           (cl-remove nil
                      (mapcar
                       (lambda (entry)
                         (let* ((created-str (alist-get 'created entry))
                                (duration (alist-get 'time entry 0))
                                (ts (and created-str
                                         (condition-case nil
                                             (date-to-time created-str)
                                           (error nil))))
                                (end-time (and ts (time-add ts (seconds-to-time duration))))
                                (start-str (and ts (format-time-string "[%Y-%m-%d %a %H:%M]" ts)))
                                (end-str (and end-time (format-time-string "[%Y-%m-%d %a %H:%M]" end-time)))
                                (h (/ duration 3600))
                                (m (/ (% duration 3600) 60)))
                           (when (and start-str end-str (> duration 0))
                             (format "CLOCK: %s--%s => %02d:%02d" start-str end-str h m))))
                       (ip-forgejo--ensure-list entries)))))
      (if formatted-entries
          (string-join formatted-entries "\n")
        ""))))

(defun ip-forgejo--format-comments (comments)
  "Format a list of COMMENTS into Org-mode subheadings."
  (if (null comments)
      ""
    (let ((formatted-comments
           (mapcar
            (lambda (comment)
              (let* ((author (alist-get 'user comment))
                     (author-name (if author (alist-get 'login author) "Unknown"))
                     (created-str (alist-get 'created_at comment))
                     (body (ip-forgejo--clean-body (alist-get 'body comment)))
                     (timestamp (if created-str
                                    (condition-case nil
                                        (format-time-string "[%Y-%m-%d %a %H:%M]"
                                                            (date-to-time created-str))
                                      (error created-str))
                                  "")))
                (format "** Comment by %s %s\n%s" author-name timestamp (or body ""))))
            (ip-forgejo--ensure-list comments))))
      (string-join formatted-comments "\n"))))

(defun ip-forgejo--format-entry (issue times)
  "Format a single ISSUE with TIMES, COMMENTS, and metadata into an Org heading."
  (let* ((title (alist-get 'title issue))
         (number (alist-get 'number issue))
         (state (alist-get 'state issue))
         (todo (ip-forgejo--org-todo-state state))
         (labels (ip-forgejo--ensure-list (alist-get 'labels issue)))
         (owner-data (alist-get 'owner (alist-get 'repository issue)))
         (owner-name (if (stringp owner-data) owner-data (alist-get 'login owner-data)))
         (repo-name (alist-get 'name (alist-get 'repository issue)))
         (id (alist-get 'id issue))
         (body (ip-forgejo--clean-body (or (alist-get 'body issue) "")))
         (total-time (cl-reduce #'+ (mapcar (lambda (e) (alist-get 'time e 0))
                                            (ip-forgejo--ensure-list times))
                                :initial-value 0))
         (logbook (ip-forgejo--format-logbook times))
         (org-id (org-id-new))
         ;; Generate Forgejo issue URL
         (base-url (car (ip-forgejo--current-config)))
         (web-url (replace-regexp-in-string "/api/v1$" "" base-url))
         (issue-url (format "%s/%s/%s/issues/%s" web-url owner-name repo-name number))
         ;; Extract dates
         (created (alist-get 'created_at issue))
         (due-date (alist-get 'deadline issue))
         ;; Format tags
         (label-tags (mapcar (lambda (lbl) (replace-regexp-in-string "[^A-Za-z0-9_]+" "_" (alist-get 'name lbl)))
                             labels))
         (all-tags (seq-uniq (append label-tags (list owner-name repo-name))))
         (tags-str (if all-tags (concat "    :" (mapconcat 'identity all-tags ":") ":") ""))
         ;; Format SCHEDULED and DEADLINE
         (scheduled-str (when created (format "SCHEDULED: <%s>" (ip-forgejo--format-org-timestamp created))))
         (deadline-str (when due-date (format "DEADLINE: <%s>" (ip-forgejo--format-org-timestamp due-date))))
         ;; Build the entry
         (properties-str (format ":PROPERTIES:\n:ID: %s\n:FORGEJO_ID: %s\n:FORGEJO_NUM: %s\n:FORGEJO_URL: %s\n:STATE: %s\n:CLIENT: %s\n:REPO: %s\n:TIME: %d\n:END:"
                                 org-id id number issue-url state owner-name repo-name total-time))
         (logbook-block (if (string-empty-p logbook)
                            ""
                          (format ":LOGBOOK:\n%s\n:END:" logbook)))
         (main-content (string-join (list body))))
    (format "* %s %s%s\n%s\n%s\n%s\n%s\n\n%s"
            todo title tags-str
            (or scheduled-str "")
            (or deadline-str "")
            properties-str
            logbook-block
            main-content)))

(defun ip-forgejo--replace-or-insert-entry (forgejo-id entry)
  "Find Org heading by FORGEJO_ID and replace its subtree with ENTRY."
  (save-excursion
    (goto-char (point-min))
    (if (re-search-forward (format ":FORGEJO_ID:[ \t]+%s" forgejo-id) nil t)
        (let ((beg (save-excursion
                     (goto-char (match-beginning 0))
                     (org-backward-heading-same-level 1)
                     (point))))
          (goto-char beg)
          (forward-line 1)
          (while (and (not (eobp)) (looking-at "^\\s-*\\(?:\\*+\\|:\\)"))
            (forward-line 1))
          (delete-region beg (point))
          (let ((inhibit-modification-hooks t))
            (insert entry)
            (insert "\n"))
          (ip-forgejo--log 'success "Updated existing entry: %s" forgejo-id))
      (goto-char (point-max))
      (let ((inhibit-modification-hooks t))
        (insert entry)
        (insert "\n\n"))
      (ip-forgejo--log 'success "Inserted new entry: %s" forgejo-id))))

;;;###autoload
(defun ip-forgejo--push-issue (forgejo-id title body state &optional repo-owner repo-name)
  "Update remote Forgejo issue with new state, body, and title."
  (let* ((config (ip-forgejo--current-config))
         (base-url (car config))
         (token (cdr config))
         (owner (or repo-owner (org-entry-get nil "CLIENT")))
         (repo (or repo-name (org-entry-get nil "REPO")))
         (url (format "%s/repos/%s/%s/issues/%d" base-url owner repo forgejo-id))
         (patch-data `((title . ,title)
                       (body . ,body)
                       (state . ,state))))
    (unless (and owner repo)
      (ip-forgejo--log 'error "Cannot determine repository owner or name for issue %d" forgejo-id)
      (error "Cannot determine repository owner or name for issue %d" forgejo-id))
    (ip-forgejo--log 'info "Pushing update to issue %d" forgejo-id)
    (request url
      :type "PATCH"
      :headers `(("Authorization" . ,(concat "token " token))
                 ("Content-Type" . "application/json"))
      :data (json-serialize patch-data)
      :sync t
      :success (cl-function (lambda (&key &allow-other-keys)
                              (ip-forgejo--log 'success "Issue %d updated" forgejo-id)))
      :error (cl-function (lambda (&key error-thrown &allow-other-keys)
                            (ip-forgejo--log 'error "Failed to update issue %d: %s"
                                             forgejo-id error-thrown))))))

;;;###autoload
(defun ip-forgejo--push-deadline (forgejo-id &optional repo-owner repo-name)
  "Push DEADLINE from current Org entry to Forgejo issue's duedate."
  (let* ((config (ip-forgejo--current-config))
         (base-url (car config))
         (token (cdr config))
         (owner (or repo-owner (org-entry-get nil "CLIENT")))
         (repo (or repo-name (org-entry-get nil "REPO")))
         (url (format "%s/repos/%s/%s/issues/%d" base-url owner repo forgejo-id))
         (deadline-str (org-entry-get nil "DEADLINE"))
         (deadline-iso8601 (when deadline-str
                             (format-time-string "%FT%T%z"
                                                 (org-time-string-to-time deadline-str)))))
    (unless (and owner repo)
      (ip-forgejo--log 'error "Cannot determine repository owner or name for issue %d" forgejo-id)
      (error "Cannot determine repository owner or name for issue %d" forgejo-id))
    (when deadline-iso8601
      (let ((patch-data `((deadline . ,deadline-iso8601))))
        (ip-forgejo--log 'info "Pushing deadline to issue %d: %s" forgejo-id deadline-iso8601)
        (request url
          :type "PATCH"
          :headers `(("Authorization" . ,(concat "token " token))
                     ("Content-Type" . "application/json"))
          :data (json-serialize patch-data)
          :sync t
          :success (cl-function (lambda (&key &allow-other-keys)
                                  (ip-forgejo--log 'success "Deadline for issue %d updated" forgejo-id)))
          :error (cl-function (lambda (&key error-thrown &allow-other-keys)
                                (ip-forgejo--log 'error "Failed to update deadline for issue %d: %s"
                                                 forgejo-id error-thrown))))))))

;;;###autoload
(defun ip-forgejo--add-time-entry (issue-id time-seconds &optional repo-owner repo-name)
  "Log time entry to Forgejo issue."
  (let* ((config (ip-forgejo--current-config))
         (base-url (car config))
         (token (cdr config))
         (owner (or repo-owner (org-entry-get nil "CLIENT")))
         (repo (or repo-name (org-entry-get nil "REPO")))
         (url (format "%s/repos/%s/%s/issues/%d/times" base-url owner repo issue-id))
         (post-data `((created . ,(format-time-string "%FT%T%z"))
                     (time . ,time-seconds))))
    (unless (and owner repo)
      (ip-forgejo--log 'error "Cannot determine repository owner or name for issue %d" issue-id)
      (error "Cannot determine repository owner or name for issue %d" issue-id))
    (request url
      :type "POST"
      :headers `(("Authorization" . ,(concat "token " token))
                 ("Content-Type" . "application/json"))
      :data (json-serialize post-data)
      :sync t
      :success (cl-function (lambda (&key &allow-other-keys)
                              (ip-forgejo--log 'success "Time logged for issue %d" issue-id)))
      :error (cl-function (lambda (&key error-thrown &allow-other-keys)
                            (ip-forgejo--log 'error "Failed to log time for issue %d: %s"
                                             issue-id error-thrown))))))

;;;###autoload
(defun ip-forgejo-list-clients ()
  "Show a list of all clients (owners) from imported issues."
  (interactive)
  (ip-debug-log 'info 'forgejo "Listing clients from imported issues")
  (let (clients)
    (org-map-entries
     (lambda ()
       (let ((client (org-entry-get nil "CLIENT")))
         (when client
           (cl-pushnew client clients :test 'equal))))
     "FORGEJO_ID>\"\"") ; only imported issues
    (with-current-buffer (get-buffer-create "*Forgejo Clients*")
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert "=== Clients (Org Owners) ===\n\n")
        (dolist (client (seq-sort 'string< clients))
          (insert (format "- %s\n" client)))
        (goto-char (point-min))
        (display-buffer (current-buffer))))
    (ip-debug-log 'success 'forgejo "Found %d unique clients" (length clients))))

;;;###autoload
(defun ip-forgejo-import-my-issues ()
  "Import or update assigned Forgejo issues in the current Org buffer."
  (interactive)
  (let* ((config (ip-forgejo--current-config))
         (base-url (car config))
         (search-url (concat base-url "/repos/issues/search"
                             "?state=all&type=issues"
                             "&assigned=true&created=false"
                             "&mentioned=false&review_requested=false"
                             "&reviewed=false&limit=100"))
         issues)
    (let ((org-element-use-cache nil)
          (font-lock-mode nil)
          (inhibit-modification-hooks t)
          (gc-cons-threshold (* 100000000 1)))
      ;; Initialize sync report buffer
      (with-current-buffer (get-buffer-create "*Forgejo Sync Report*")
        (let ((inhibit-read-only t))
          (erase-buffer)
          (ip-forgejo--log 'info "=== Forgejo Synchronization Report ===")
          (ip-forgejo--log 'info "Time: %s" (current-time-string))
          (ip-forgejo--log 'info "Instance: %s" ip-forgejo-current-instance)
          (ip-forgejo--log 'info "Base URL: %s" base-url)
          (ip-forgejo--log 'info "Search URL: %s" search-url)
          (condition-case err
              (progn
                (setq issues (ip-forgejo--api search-url))
                (if issues
                    (progn
                      (ip-forgejo--log 'success "API Request: Success")
                      (ip-forgejo--log 'info "Total issues retrieved: %d" (length issues))
                      (ip-forgejo--log 'info "Issues processed:")
                      (dolist (issue issues)
                        (let* ((title (alist-get 'title issue))
                               (state (alist-get 'state issue))
                               (repo (alist-get 'repository issue))
                               (repo-name (alist-get 'name repo))
                               (number (alist-get 'number issue)))
                          (ip-forgejo--log 'info "  • [%s/%d] %s [%s]" repo-name number title state))))
                    (ip-forgejo--log 'warning "API Request: Success, but empty list.")))
            (error
             (ip-forgejo--log 'error "API Request: FAILED — %S" err)
             (setq issues nil)))
          (ip-forgejo--log 'info "=== Raw Response (first issue) ===")
          (if issues
              (let ((str (prin1-to-string (car issues))))
                (ip-forgejo--log 'info "%s" (if (> (length str) 1000)
                                                (concat (substring str 0 1000) " [...]")
                                              str)))
            (ip-forgejo--log 'info "nil (no issues)"))
          (ip-forgejo--log 'info "=== Processing Issues ===")
          (goto-char (point-min))
          (display-buffer (current-buffer))))
      (unless issues
        (ip-debug-log 'error 'forgejo "No issues received from API")
        (user-error "No issues received from API"))
      (save-excursion
        (dolist (issue issues)
          (let* ((repo (alist-get 'repository issue))
                 (owner-data (alist-get 'owner repo))
                 (owner-name (if (stringp owner-data)
                                 owner-data
                               (alist-get 'login owner-data)))
                 (repo-name (alist-get 'name repo))
                 (index (alist-get 'number issue))
                 (times-url (format "%s/repos/%s/%s/issues/%s/times"
                                    base-url
                                    owner-name
                                    repo-name
                                    index))
                 (comments-url (format "%s/repos/%s/%s/issues/%s/comments"
                                       base-url
                                       owner-name
                                       repo-name
                                       index))
                 times comments entry title)
            ;; Get time logs
            (condition-case err
                (progn
                  (setq times (ip-forgejo--api times-url))
                  (setq times (ip-forgejo--ensure-list times)))
              (error
               (ip-forgejo--log 'warning "Failed to fetch times for #%d: %s" index (error-message-string err))
               (setq times nil)))
            ;; Get comments
            (condition-case err
                (progn
                  (setq comments (ip-forgejo--api comments-url))
                  (setq comments (ip-forgejo--ensure-list comments)))
              (error
               (ip-forgejo--log 'warning "Failed to fetch comments for #%d: %s" index (error-message-string err))
               (setq comments nil)))
            (setq title (alist-get 'title issue))
            (setq entry (ip-forgejo--format-entry issue times))
            (ip-forgejo--replace-or-insert-entry (alist-get 'id issue) entry)
            (ip-forgejo--log 'success "✓ Imported: %s" title)))
        (ip-forgejo--log 'success "=== Import Complete ===")
        (ip-debug-log 'success 'forgejo "Import completed: %d issues processed" (length issues))))))

;;;###autoload
(defun ip-forgejo--on-save-hook ()
  "Push deadline and state if current entry is a Forgejo issue."
  (when (org-before-first-heading-p)
    (cl-return-from ip-forgejo--on-save-hook))
  (save-excursion
    (org-back-to-heading t)
    (let ((forgejo-id (org-entry-get nil "FORGEJO_ID")))
      (when forgejo-id
        (ip-debug-log 'info 'forgejo "Auto-syncing deadline for issue %s" forgejo-id)
        (ip-forgejo--push-deadline (string-to-number forgejo-id))))))

;;;###autoload
(defun ip-forgejo-show-sync-report ()
  "Display the Forgejo sync report buffer."
  (interactive)
  (let ((buffer (get-buffer "*Forgejo Sync Report*")))
    (if buffer
        (display-buffer buffer)
      (message "No sync report available. Run ip-forgejo-import-my-issues first."))))

(add-hook 'org-after-save-hook 'ip-forgejo--on-save-hook)

(provide 'ip-forgejo)
;;; ip-forgejo.el ends here;;; ip-invoice.el --- Generate invoices from org-mode tasks -*- coding: utf-8; lexical-binding: t; -*-
;;; Commentary:
;; This module generates invoices from org-mode tasks for the IP management system.
;; Supports service-based and task-based invoices using org-mode clock entries.
;; Reads company and client data from Org-files via ip-core.el.
;; Outputs HTML invoices using mustache.el templates.
;; Fetches EUR/RSD exchange rate via API and validates payment data with NBS IPS API.
;;; Code:
(eval-and-compile
  ;; Fallback logging if ip-debug is not available
  (unless (fboundp 'ip-debug-log)
    (defun ip-debug-log (level module message &rest args)
      "Fallback logging function that uses `message'."
      (let ((formatted-msg (apply #'format message args))
            (level-str (pcase level
                         ('info "INFO")
                         ('success "SUCCESS")
                         ('warning "WARNING")
                         ('error "ERROR")
                         (_ "DEBUG")))
            (module-str (upcase (symbol-name module))))
        (message "[%s/%s] %s" module-str level-str formatted-msg))))
  (unless (fboundp 'ip-debug)
    (defmacro ip-debug (module message &rest args)
      "Fallback debug macro that uses `ip-debug-log'."
      `(ip-debug-log 'info ,module ,message ,@args))))
(require 'cl-lib)
(require 'org)
(require 'org-clock)
(require 'org-element)
(require 'ip-core)          ; Now provides client/company data
(require 'mustache)
(require 'subr-x)
(require 'json)

(condition-case nil
    (require 'ip-debug)
  (error
   (ip-debug-log 'warning 'invoice "Failed to load ip-debug.el, using fallback logging")))

;;; Customization
(defgroup ip-invoice nil
  "Invoice generation for IP management system."
  :group 'ip-core)

(defcustom ip-invoice-final-dir (expand-file-name "invoices/2025/" ip-org-directory)
  "Directory to store finalized invoices."
  :type 'directory
  :group 'ip-invoice)

(defcustom ip-invoice-draft-dir (expand-file-name "invoices/drafts/" ip-org-directory)
  "Directory to store draft invoices."
  :type 'directory
  :group 'ip-invoice)

(defcustom ip-invoice-template-file nil
  "Path to custom HTML invoice template. If nil, uses default template."
  :type '(choice (file :tag "Template file")
                 (const :tag "Default template" nil))
  :group 'ip-invoice)

(defcustom ip-invoice-type 'task
  "Default invoice type: \\='service (group by services) or \\='task (group by tasks)."
  :type '(choice (const :tag "Group by services" service)
                 (const :tag "Group by tasks" task))
  :group 'ip-invoice)

(defcustom ip-invoice-minimal-template
  "<!DOCTYPE html>
<html lang=\"en\">
<head>
    <meta charset=\"UTF-8\">
    <title>Invoice {{invoice_number}}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .header, .details, .total { margin-bottom: 20px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .total { font-weight: bold; }
    </style>
</head>
<body>
    <div class=\"header\">
        <h1>{{company.name}}</h1>
        <p>{{company.address}}</p>
        <p>Email: {{company.email}}</p>
        <p>PIB: {{company.pib}} | Matični broj: {{company.maticni_broj}}</p>
        <p>Tekući račun: {{company.iban}}</p>
        <h2>Client: {{client}}</h2>
        <p>{{client_address}}</p>
        <p>Email: {{client_email}}</p>
    </div>
    <div class=\"details\">
        <p><strong>Račun br.:</strong> {{invoice_number}}</p>
        <p><strong>Mesec:</strong> {{month}}</p>
        <p><strong>Datum izdavanja:</strong> {{generated}}</p>
        <p><strong>Rok dospeća:</strong> {{next_month}}-20</p>
        <p><strong>Devizni kurs:</strong> 1 EUR = {{exchange_rate}} RSD</p>
    </div>
    <table>
        <thead>
            <tr>
                <th>Task Description</th>
                <th>Hours</th>
                <th>Amount (RSD)</th>
            </tr>
        </thead>
        <tbody>
            {{#task_summary}}
            <tr>
                <td>{{description}}</td>
                <td>{{total_hours}}</td>
                <td>{{amount_rsd}}</td>
            </tr>
            {{/task_summary}}
            {{^task_summary}}
            <tr>
                <td colspan=\"3\">No tasks recorded for this period</td>
            </tr>
            {{/task_summary}}
            <tr class=\"total\">
                <td><strong>Total</strong></td>
                <td><strong>{{total_hours}}</strong></td>
                <td><strong>{{total_amount_rsd}} RSD</strong></td>
            </tr>
        </tbody>
    </table>
    <div class=\"total\">
        <p><strong>Rate:</strong> €{{client_rate}}/hour</p>
        <p><strong>Total Amount (EUR):</strong> €{{total_amount_eur}}</p>
        <p><strong>Total Amount (RSD):</strong> {{total_amount_rsd}} RSD</p>
    </div>
    <div class=\"footer\">
        <p>Generated on {{generated}}</p>
    </div>
</body>
</html>"
  "Minimal HTML template for task-based invoices."
  :type 'string
  :group 'ip-invoice)

(defcustom ip-invoice-task-template
  "<!DOCTYPE html>
<html lang=\"en\">
<head>
    <meta charset=\"UTF-8\">
    <title>Invoice {{invoice_number}}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .invoice-container { max-width: 800px; margin: auto; }
        .header, .details, .total, .payment-slip { margin-bottom: 20px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .total { font-weight: bold; }
        .payment-slip .row { display: flex; justify-content: space-between; margin-bottom: 10px; }
        .payment-slip .col { flex: 1; margin-right: 10px; }
        .payment-slip .col:last-child { margin-right: 0; }
        .payment-slip label { font-weight: bold; }
        .potpis-line { border-top: 1px solid #000; width: 200px; margin-top: 20px; }
    </style>
</head>
<body>
    <div class=\"invoice-container\">
        <div class=\"header\">
            {{#company.logo}}
            <img src=\"{{company.logo}}\" alt=\"{{company.name}}\" style=\"max-width: 150px;\">
            {{/company.logo}}
            {{^company.logo}}
            <img src=\"\" alt=\"{{company.name}}\" style=\"max-width: 150px;\">
            {{/company.logo}}
            <div class=\"company-info\">
                <h1>{{company.name}}</h1>
                <p>{{company.address}}</p>
                <p>Email: {{company.email}}</p>
                <p>PIB: {{company.pib}} | Matični broj: {{company.maticni_broj}}</p>
                <p>Tekući račun: {{company.iban}}</p>
            </div>
            <div class=\"client-info\">
                <p><strong>{{client}}</strong></p>
                <p>{{client_address}}</p>
                <p>Email: {{client_email}}</p>
                <p>{{client_payment_details}}</p>
            </div>
        </div>
        <div class=\"details\">
            <div>
                <p><strong>Račun br.:</strong> {{invoice_number}} na osnovu ugovora {{agreement}}</p>
                <p><strong>Mesec:</strong> {{month}}</p>
                <p><strong>Datum izdavanja:</strong> {{generated}}</p>
                <p><strong>Rok dospeća:</strong> {{next_month}}-20</p>
            </div>
            <div>
                <p><strong>Devizni kurs:</strong> 1 EUR = {{exchange_rate}} RSD</p>
                <p><strong>Mesto izdavanja:</strong> {{company.address}}</p>
            </div>
        </div>
        <table>
            <thead>
                <tr>
                    <th>Task Description</th>
                    <th>Hours</th>
                    <th>Amount (RSD)</th>
                </tr>
            </thead>
            <tbody>
                {{#task_summary}}
                <tr>
                    <td>{{description}}</td>
                    <td>{{total_hours}}</td>
                    <td>{{amount_rsd}}</td>
                </tr>
                {{/task_summary}}
                {{^task_summary}}
                <tr>
                    <td colspan=\"3\">No tasks recorded for this period</td>
                </tr>
                {{/task_summary}}
                <tr class=\"total\">
                    <td><strong>Total</strong></td>
                    <td><strong>{{total_hours}}</strong></td>
                    <td><strong>{{total_amount_rsd}} RSD</strong></td>
                </tr>
            </tbody>
        </table>
        <div class=\"total\">
            <p><strong>Rate:</strong> €{{client_rate}}/hour</p>
            <p><strong>Total Amount (EUR):</strong> €{{total_amount_eur}}</p>
            <p><strong>Total Amount (RSD):</strong> {{total_amount_rsd}} RSD</p>
        </div>
        <div class=\"payment-slip\">
            <div class=\"row\">
                <div class=\"col uplatilac\">
                    <label>Uplatilac</label>
                    <div>{{client}}<br>{{client_address}}</div>
                </div>
                <div class=\"col shifra\">
                    <label>Šifra plaćanja</label>
                    <div>189</div>
                </div>
                <div class=\"col valuta\">
                    <label>Valuta</label>
                    <div>RSD</div>
                </div>
                <div class=\"col iznos\">
                    <label>Iznos</label>
                    <div>{{total_amount_rsd}}</div>
                </div>
            </div>
            <div class=\"row\">
                <div class=\"col svrha\">
                    <label>Svrha uplate</label>
                    <div>Račun {{invoice_number}} za {{month}}</div>
                </div>
                <div class=\"col racun\">
                    <label>Račun primaoca</label>
                    <div>{{company.iban}}</div>
                </div>
            </div>
            <div class=\"row\">
                <div class=\"col primalac\">
                    <label>Primalac</label>
                    <div>{{company.name}}<br>{{company.address}}</div>
                </div>
                <div class=\"col model\">
                    <label>Model</label>
                    <div>{{company.model}}</div>
                </div>
                <div class=\"col poziv\">
                    <label>Poziv na broj</label>
                    <div>{{company.poziv_base}}-{{month}}-{{invoice_number}}</div>
                </div>
            </div>
            <div class=\"row bottom\">
                <div class=\"col potpis\">
                    <label>Datum i potpis nalogodavca:</label>
                    <div class=\"potpis-line\"></div>
                    <em>Račun važi bez pečata i potpisa</em>
                </div>
                <div class=\"col qr\">
                    <label>NBS IPS QR</label>
                    <img src=\"data:image/png;base64,{{qr_code}}\" alt=\"QR kod\">
                </div>
            </div>
        </div>
        <div class=\"footer\">
            <p>Generated on {{generated}} | Thank you for your business!</p>
        </div>
    </div>
</body>
</html>"
  "HTML template for task-based invoices with QR code."
  :type 'string
  :group 'ip-invoice)

(defcustom ip-invoice-exchange-rate-api
  "https://kurs.resenje.org/api/v1/rates"
  "API URL for fetching EUR/RSD exchange rate."
  :type 'string
  :group 'ip-invoice)

(defcustom ip-invoice-nbs-validate-url
  "https://nbs.rs/QRcode/api/qr/v1/validate?lang=sr_RS"
  "URL for validating payment data via NBS IPS API."
  :type 'string
  :group 'ip-invoice)

(defcustom ip-invoice-nbs-qr-generate-url
  "https://nbs.rs/QRcode/api/qr/v1/generate?lang=sr_RS"
  "URL for generating NBS IPS QR code."
  :type 'string
  :group 'ip-invoice)

(defcustom ip-invoice-agreement "AG2025-001"
  "Default agreement number for invoices."
  :type 'string
  :group 'ip-invoice)

;;; Fixed Functions

(defun ip-invoice--get-exchange-rate ()
  "Fetch EUR/RSD exchange rate from Kurs API."
  (ip-debug-log 'info 'invoice "Fetching EUR/RSD exchange rate from %s" ip-invoice-exchange-rate-api)
  (let ((buffer
         (let ((url-request-method "GET")
               (url-request-extra-headers '(("Accept" . "application/json"))))
           (url-retrieve-synchronously ip-invoice-exchange-rate-api t))))
    (if (not buffer)
        (progn
          (ip-debug-log 'error 'invoice "Failed to fetch exchange rate")
          (error "Failed to fetch exchange rate"))
      (with-current-buffer buffer
        (set-buffer-file-coding-system 'utf-8)
        (goto-char (point-min))
        (re-search-forward "\r?\n\r?\n" nil t)
        (let ((json-object-type 'plist)
              (response (json-read)))
          (let ((eur-rate (cl-find-if (lambda (r) (string= (plist-get r :code) "EUR")) response)))
            (if eur-rate
                (let ((rate (plist-get eur-rate :exchange_middle)))
                  (ip-debug-log 'info 'invoice "Fetched exchange rate: %.2f" rate)
                  rate)
              (progn
                (ip-debug-log 'error 'invoice "EUR rate not found in API response")
                (error "EUR rate not found in API response")))))))))

(defun ip-invoice--validate-payment-data (payment-data)
  "Validate PAYMENT-DATA string via NBS IPS API."
  (ip-debug-log 'info 'invoice "Validating payment data: %s" payment-data)
  (let ((buffer
         (let ((url-request-method "POST")
               (url-request-extra-headers '(("Content-Type" . "text/plain")))
               (url-request-data (encode-coding-string payment-data 'utf-8)))
           (url-retrieve-synchronously ip-invoice-nbs-validate-url t))))
    (if (not buffer)
        (progn
          (ip-debug-log 'error 'invoice "HTTP request failed for validation")
          (error "HTTP request failed for validation"))
      (with-current-buffer buffer
        (set-buffer-file-coding-system 'utf-8)
        (goto-char (point-min))
        (if (re-search-forward "HTTP/[0-9.]+ 200 OK" nil t)
            (progn
              (re-search-forward "\r?\n\r?\n" nil t)
              (let ((json-object-type 'plist)
                    (response (json-read)))
                (if (eq (plist-get (plist-get response :s) :code) 0)
                    (progn
                      (ip-debug-log 'info 'invoice "Payment data validated successfully")
                      t)
                  (progn
                    (ip-debug-log 'error 'invoice "Validation failed: %s"
                                  (plist-get (plist-get response :s) :desc))
                    (error "Validation failed: %s"
                           (plist-get (plist-get response :s) :desc)))))
          (progn
            (ip-debug-log 'error 'invoice "HTTP request failed for validation")
            (error "HTTP request failed for validation"))))))))

(defun ip-invoice--generate-qr-code (invoice)
  "Generate NBS IPS QR code for INVOICE if template requires it."
  (let* ((company (plist-get invoice :company))
         (client (plist-get invoice :client))
         (total-amount-rsd (plist-get invoice :total_amount_rsd))
         (invoice-number (plist-get invoice :invoice_number))
         (month (plist-get invoice :month))
         (poziv-na-broj (format "%s-%s-%s"
                                (plist-get company :poziv_base)
                                month
                                invoice-number))
         (qr-data (format "K:PR|V:01|C:1|R:%s|N:%s|I:RSD%s|P:%s|SF:189|S:Račun %s za %s|RO:%s"
                          (plist-get company :iban)
                          (concat (plist-get company :name) "\r\n" (plist-get company :address))
                          total-amount-rsd
                          (concat client "\r\n" (plist-get invoice :client_address))
                          invoice-number
                          month
                          poziv-na-broj)))
    (ip-invoice--validate-payment-data qr-data)
    (ip-debug-log 'info 'invoice "Generating QR code with data: %s" qr-data)
    (let ((buffer
           (let ((url-request-method "POST")
                 (url-request-extra-headers '(("Content-Type" . "text/plain")))
                 (url-request-data (encode-coding-string qr-data 'utf-8)))
             (url-retrieve-synchronously ip-invoice-nbs-qr-generate-url t))))
      (if (not buffer)
          (progn
            (ip-debug-log 'error 'invoice "HTTP request failed for QR code")
            (error "HTTP request failed for QR code"))
        (with-current-buffer buffer
          (set-buffer-file-coding-system 'utf-8)
          (goto-char (point-min))
          (if (re-search-forward "HTTP/[0-9.]+ 200 OK" nil t)
              (progn
                (re-search-forward "\r?\n\r?\n" nil t)
                (let ((json-object-type 'plist)
                      (response (json-read)))
                  (if (eq (plist-get (plist-get response :s) :code) 0)
                      (let ((qr-base64 (plist-get response :i)))
                        (ip-debug-log 'info 'invoice "QR code generated successfully")
                        qr-base64)
                    (progn
                      (ip-debug-log 'error 'invoice "QR code generation failed: %s"
                                    (plist-get (plist-get response :s) :desc))
                      (error "QR code generation failed: %s"
                             (plist-get (plist-get response :s) :desc)))))
            (progn
              (ip-debug-log 'error 'invoice "HTTP request failed for QR code")
              (error "HTTP request failed for QR code")))))))))

(defun ip-invoice--month-from-date (date)
  "Return month name from DATE in format 'January 2025'."
  (format-time-string "%B %Y" (org-time-string-to-time date)))

(defun ip-invoice--next-month-from-date (date)
  "Return next month name from DATE in format 'January 2025'."
  (format-time-string "%B %Y" (time-add (org-time-string-to-time date) (days-to-time 30))))

(defun ip-invoice--generate-invoice-id ()
  "Generate a unique invoice ID."
  (format-time-string "%Y%m%d-%H%M%S"))

(defun ip-invoice--get-task-clock-entries (element start end)
  "Get clock entries for ELEMENT between START and END."
  (let (entries)
    (org-element-map element 'clock
      (lambda (clock)
        (let ((timestamp (org-element-property :value clock))
              (duration (org-element-property :duration clock)))
          (when (and timestamp duration)
            (let* ((date (org-timestamp-to-time timestamp))
                   (entry-date (format-time-string "%Y-%m-%d" date)))
              (when (and (org-time<= (org-time-string-to-time start) date)
                         (org-time>= (org-time-string-to-time end) date))
                (push (list :date entry-date
                            :hours (/ (float (org-duration-to-minutes duration)) 60.0))
                      entries))))))
    (nreverse entries))))

(defun ip-invoice-generate-data (client-id start end &optional state invoice-type)
  "Generate invoice data for CLIENT-ID from START to END.
  STATE is \\='draft or \\='final. INVOICE-TYPE is \\='service or \\='task."
  (ip-debug-log 'info 'invoice "Generating invoice for %s (%s to %s, type: %s)"
                client-id start end (or invoice-type ip-invoice-type))
  (let* ((client-id (string-trim client-id))
         (client (or (ip-get-client-by-id client-id)
                     (progn
                       (ip-debug-log 'error 'invoice "Unknown client ID: %s" client-id)
                       (error "Unknown client ID: %s" client-id))))
         (client-name (or (plist-get client :NAME) client-id))
         (currency "EUR")
         (tax-rate (string-to-number (or (plist-get client :TAX_RATE) "0")))
         (default-rate (string-to-number (or (plist-get client :DEFAULT_RATE) "0")))
         (invoice-type (or invoice-type ip-invoice-type))
         (invoice-id (if (eq state 'final) (ip-invoice--generate-invoice-id) (format "%s-%s" client-id (format-time-string "%Y%m%d"))))
         (month (ip-invoice--month-from-date start))
         (next-month (ip-invoice--next-month-from-date start))
         (generated (format-time-string "%Y-%m-%d"))
         (exchange-rate (ip-invoice--get-exchange-rate))
         (agreement (or (plist-get client :AGREEMENT) ip-invoice-agreement))
         (company (ip-get-company-info)))
    (ip-debug-log 'info 'invoice "Client: %s, currency: %s, tax-rate: %.2f, default-rate: %.2f"
                  client-name currency tax-rate default-rate)
    (cond
     ((eq invoice-type 'service)
      (let* ((tasks (ip-invoice--load-tasks start end))
             (filtered (cl-remove-if-not
                        (lambda (task)
                          (let ((valid (and task (string= (string-trim (plist-get task :client)) client-id))))
                            (ip-debug-log 'info 'invoice "Filtering task: %s, client: %s, hours: %.2f, valid: %S"
                                          (plist-get task :title) (plist-get task :client)
                                          (plist-get task :hours) valid)
                            valid))
                        tasks))
             (grouped (make-hash-table :test 'equal))
             (services ())
             (subtotal 0.0))
        (dolist (task filtered)
          (when-let ((hours (plist-get task :hours))
                     (service (string-trim (plist-get task :service))))
            (puthash service
                     (+ (gethash service grouped 0.0) hours)
                     grouped)))
        (maphash
         (lambda (svc hours)
           (let* ((svc-data (ip-get-client-service client-id svc))
                  (rate (string-to-number (or (plist-get svc-data :RATE)
                                              (plist-get client :DEFAULT_RATE)
                                              "0")))
                  (amount (* rate hours)))
             (ip-debug-log 'info 'invoice "Service %s: %.2f hours @ %.2f = %.2f"
                           svc hours rate amount)
             (push (list :description (or (plist-get svc-data :description) svc)
                         :hours (format "%.2f" hours)
                         :rate (format "%.2f" rate)
                         :amount (format "%.2f" amount)
                         :taxable (plist-get svc-data :taxable))
                   services)
             (setq subtotal (+ subtotal amount))))
         grouped)
        (let ((tax-amount (* subtotal (/ tax-rate 100.0))))
          (list :client (plist-put client :name client-name)
                :start start
                :end end
                :state (or state 'draft)
                :invoice-id invoice-id
                :type 'service
                :currency currency
                :services (nreverse services)
                :subtotal (format "%.2f" subtotal)
                :tax-rate tax-rate
                :tax-amount (format "%.2f" tax-amount)
                :total (format "%.2f" (+ subtotal tax-amount)))))

     ((eq invoice-type 'task)
      (let* ((tasks (ip-invoice--load-tasks start end))
             (filtered (cl-remove-if-not
                        (lambda (task)
                          (let ((valid (and task (string= (string-trim (plist-get task :client)) client-id))))
                            (ip-debug-log 'info 'invoice "Filtering task: %s, client: %s, hours: %.2f, valid: %S"
                                          (plist-get task :title) (plist-get task :client)
                                          (plist-get task :hours) valid)
                            valid))
                        tasks))
             (task-entries ())
             (task-summary (make-hash-table :test 'equal))
             (subtotal 0.0)
             (total-hours 0.0))
        (dolist (task filtered)
          (when-let ((service (string-trim (plist-get task :service)))
                     (title (plist-get task :title))
                     (element (plist-get task :element))
                     (svc-data (ip-get-client-service client-id service))
                     (rate (string-to-number (or (plist-get svc-data :RATE)
                                                 (plist-get client :DEFAULT_RATE)
                                                 "0"))))
            (dolist (entry (ip-invoice--get-task-clock-entries element start end))
              (let ((hours (plist-get entry :hours))
                    (date (plist-get entry :date)))
                (ip-debug-log 'info 'invoice "Task entry: %s, %s, %.2f hours"
                              date title hours)
                (push (list :date date
                            :task (encode-coding-string title 'utf-8)
                            :hours hours)
                      task-entries)
                (puthash title
                         (+ (gethash title task-summary 0.0) hours)
                         task-summary)
                (setq subtotal (+ subtotal (* rate hours)))
                (setq total-hours (+ total-hours hours))))))
        (let* ((tax-amount (* subtotal (/ tax-rate 100.0)))
               (total-amount-eur (+ subtotal tax-amount))
               (total-amount-rsd (* total-amount-eur exchange-rate))
               (summary-list (let (result)
                               (maphash
                                (lambda (task hours)
                                  (push (list :description (encode-coding-string task 'utf-8)
                                              :total_hours (format "%.2f" hours)
                                              :amount_rsd (format "%.2f" (* hours default-rate exchange-rate)))
                                        result))
                                task-summary)
                               (nreverse result))))
          (list :client client-name
                :client_address (encode-coding-string (or (plist-get client :ADDRESS) "N/A") 'utf-8)
                :client_email (encode-coding-string (or (plist-get client :EMAIL) "N/A") 'utf-8)
                :client_payment_details (encode-coding-string (or (plist-get client :PAYMENT_DETAILS) "N/A") 'utf-8)
                :client_rate (format "%.2f" default-rate)
                :invoice_number invoice-id
                :company (list :name (encode-coding-string (plist-get company :NAME) 'utf-8)
                               :address (encode-coding-string (plist-get company :ADDRESS) 'utf-8)
                               :email (encode-coding-string (plist-get company :EMAIL) 'utf-8)
                               :pib (encode-coding-string (plist-get company :TAX_ID) 'utf-8)
                               :maticni_broj (encode-coding-string (plist-get company :MATICNI_BROJ) 'utf-8)
                               :iban (encode-coding-string (plist-get company :IBAN) 'utf-8)
                               :model (encode-coding-string (or (plist-get company :MODEL) "97") 'utf-8)
                               :poziv_base (encode-coding-string (or (plist-get company :POZIV_BASE) "000") 'utf-8)
                               :props (list :logo (encode-coding-string (or (plist-get company :LOGO) "") 'utf-8)))
                :month (encode-coding-string month 'utf-8)
                :generated (encode-coding-string generated 'utf-8)
                :next_month (encode-coding-string next-month 'utf-8)
                :exchange_rate (format "%.2f" exchange-rate)
                :agreement (encode-coding-string agreement 'utf-8)
                :entries (sort task-entries
                               (lambda (a b) (string< (plist-get a :date) (plist-get b :date))))
                :task_summary summary-list
                :total_hours (format "%.2f" total-hours)
                :total_amount_eur (format "%.2f" total-amount-eur)
                :total_amount_rsd (format "%.2f" total-amount-rsd)
                :state (or state 'draft)
                :type 'task
                :qr_code (if (bound-and-true-p ip-invoice-template-file)
                             (ip-invoice--generate-qr-code
                              (list :company company
                                    :client client-name
                                    :client_address (plist-get client :ADDRESS)
                                    :total_amount_rsd (format "%.2f" total-amount-rsd)
                                    :invoice_number invoice-id
                                    :month month))
                           ""))))
     (t
      (ip-debug-log 'error 'invoice "Unknown invoice type: %s" invoice-type)
      (error "Unknown invoice type: %s" invoice-type)))))))

;; Remaining functions (ip-invoice--convert-plist-to-mustache-data, ip-invoice--generate-html, etc.) unchanged
;; (Include them as in original, they are correct)

(defun ip-invoice--convert-plist-to-mustache-data (plist)
  "Convert a PLIST with keyword keys to a Mustache-compatible alist."
  (let (result)
    (while plist
      (let ((key (car plist))
            (value (cadr plist)))
        (push (cons (substring (symbol-name key) 1)
                    (cond
                     ((and (listp value) (not (null value)) (keywordp (car value)))
                      (ip-invoice--convert-plist-to-mustache-data value))
                     ((and (listp value) (listp (car value)))
                      (mapcar #'ip-invoice--convert-plist-to-mustache-data value))
                     (t value)))
              result)
        (setq plist (cddr plist))))
    (nreverse result)))

(defun ip-invoice--generate-html (invoice output-file)
  "Generate HTML invoice from INVOICE data to OUTPUT-FILE."
  (ip-debug-log 'info 'invoice "Generating HTML invoice: %s" output-file)
  (let* ((template (if (and ip-invoice-template-file
                           (file-exists-p ip-invoice-template-file))
                      (progn
                        (ip-debug-log 'info 'invoice "Using custom template: %s" ip-invoice-template-file)
                        (with-temp-buffer
                          (set-buffer-file-coding-system 'utf-8)
                          (insert-file-contents ip-invoice-template-file)
                          (buffer-string)))
                    (if (eq (plist-get invoice :type) 'task)
                        (progn
                          (ip-debug-log 'info 'invoice "Using task template")
                          ip-invoice-task-template)
                      (progn
                        (ip-debug-log 'info 'invoice "Using default template")
                        ip-invoice-minimal-template))))
         (data (ip-invoice--convert-plist-to-mustache-data invoice)))
    (condition-case err
        (with-temp-file output-file
          (set-buffer-file-coding-system 'utf-8)
          (insert (mustache-render template data))
          (write-region (point-min) (point-max) output-file nil 'silent)
          (ip-debug-log 'success 'invoice "HTML invoice generated: %s" output-file))
      (error
       (ip-debug-log 'error 'invoice "Failed to generate HTML: %s" (error-message-string err))
       (error "Failed to generate HTML: %s" (error-message-string err))))))

(defun ip-invoice--load-tasks (start end)
  "Load Org-mode clock entries between START and END."
  (org-agenda nil "a")
  (let ((files (org-agenda-files))
        tasks)
    (dolist (file files)
      (with-current-buffer (find-file-noselect file)
        (org-element-map (org-element-parse-buffer) 'headline
          (lambda (headline)
            (when (org-element-property :CLOCK headline)
              (let ((client (org-element-property :CLIENT headline))
                    (service (org-element-property :SERVICE headline))
                    (title (org-element-property :title headline))
                    (hours (org-clock-sum start end headline)))
                (when (and client service (> hours 0))
                  (push (list :client client
                              :service service
                              :title title
                              :hours hours
                              :element headline)
                        tasks)))))))
    (nreverse tasks))))

(defun ip-invoice-generate (client-id start end &optional state invoice-type)
  "Generate an invoice for CLIENT-ID from START to END.
STATE is \\='draft or \\='final. INVOICE-TYPE is \\='service or \\='task.
Saves the invoice to `ip-invoice-draft-dir' or `ip-invoice-final-dir'."
  (let* ((invoice (ip-invoice-generate-data client-id start end state invoice-type))
         (output-dir (if (eq state 'final) ip-invoice-final-dir ip-invoice-draft-dir))
         (output-file (expand-file-name (format "%s-%s.html" client-id (plist-get invoice :invoice_number)) output-dir)))
    (unless (file-directory-p output-dir)
      (make-directory output-dir t))
    (ip-invoice--generate-html invoice output-file)
    output-file))

(provide 'ip-invoice)
;;; ip-invoice.el ends here